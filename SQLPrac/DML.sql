/*
INSERT INTO TB(COL1, COL2...)
VALUES ( VAL1,VAL2,VAL3...)
*/

INSERT INTO EMP VALUES
(7701,'JONG LEE','MANAGER',7839,to_date('2022-01-01','YYYY-MM-DD'),3000,NULL,50);

INSERT INTO DEPT VALUES
    (50,'SECURITY','SEOUL');
    
INSERT INTO EMP VALUES
(7702,'HO KIM','MANAGER',7839,to_date('2022-01-01','YYYY-MM-DD'),3000,NULL,50);

--프라이머리 키는 뺼수 없고 nulld은 가능
INSERT INTO EMP (ENAME, EMPNO, DEPTNO) 
VALUES ('RONALDO',7703,30);

/*
    UPDATE TB
    SET COL1=VAL1, COL2=VAL2,...
    WHERE CON;
*/
UPDATE EMP
SET JOB='CLERK', DEPTNO=NULL
WHERE EMPNO=7703;

UPDATE EMP
SET DEPTNO=50
WHERE EMPNO=7701;

/*
DELETE FROM TB WHERE CON;
*/

--DELETE FROM EMP
--WHERE EMPNO=7701;

/* 
    GROUP BY
    SELECT COLS (COUNT MAX MIN SUM AVG)
    FROM TB
    WHERE CONDITION
    GROUP BY COLS
    
    같은 부서끼리 묶인다
    한개의 부서에 들어가 있는 건 여러개인데 
    뭘 출력해야 하는지 알 수가 없어서 작성할 수 있는 콜럼의 제약이 생긴다
*/

SELECT JOB, COUNT(*), MAX(SAL), MIN(SAL), AVG(SAL),SUM(SAL)
FROM EMP
GROUP BY JOB;

SELECT JOB, COUNT(*), MAX(SAL), MIN(SAL), AVG(SAL),SUM(SAL)
FROM EMP
GROUP BY JOB
HAVING MIN(SAL)>1000;

SELECT JOB, COUNT(*), MAX(SAL), MIN(SAL), AVG(SAL),SUM(SAL),MIN(COMM)
FROM EMP
GROUP BY JOB
HAVING MIN(COMM) IS NULL;

SELECT JOB, COUNT(*), MAX(SAL), MIN(SAL), AVG(SAL),SUM(SAL)
FROM EMP
GROUP BY JOB
HAVING MAX(COMM) IS NULL
ORDER BY JOB;

/*CASE*/
SELECT ENAME
    ,CASE
        WHEN SAL>2000 THEN '부자'
        WHEN SAL>1000 THEN '그냥'
        ELSE '가난'
    END AS STATE
FROM EMP;

SELECT ENAME, DEPTNO, COMM
    ,CASE
        WHEN SAL>2000 THEN '부자'
        WHEN SAL>1000 THEN '그냥'
        ELSE '가난'
    END AS STATE
FROM EMP
ORDER BY COMM,ENAME;
    
SELECT A.ENAME, D.DNAME, D.LOC
FROM EMP A, DEPT D
WHERE A.DEPTNO = D.DEPTNO
AND JOB=(CASE
        WHEN SAL<1000 THEN 'CLERK'
        WHEN SAL>2000 THEN 'MANAGER'
        ELSE 'BOSS'
        END);

/*NULL FUNCTION
IFNULL() ISNULL() NVL() COALESCE()
*/
SELECT ENAME,COMM
FROM EMP;

SELECT ENAME,SAL,COMM,SAL+COMM
FROM EMP;

SELECT ENAME,SAL,COMM,SAL+NVL(COMM,0)
FROM EMP;

SELECT ENAME,SAL,COMM
    ,SAL+NVL(COMM,0) AS PAY
    ,SAL+COALESCE(COMM,0) AS PAY2
FROM EMP;

SELECT DEPTNO, JOB, COUNT(*),MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO,JOB); --중간중간 그룹 처리

SELECT DEPTNO, JOB, COUNT(*),MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO,JOB)
ORDER BY DEPTNO, JOB; -- 뒤에서 한번에 따로 처리

SELECT DEPTNO
    ,LISTAGG(ENAME,'/')WITHIN GROUP(ORDER BY ENAME)
FROM EMP
GROUP BY DEPTNO;

--DPIVOT 돌다 회전시킨다
SELECT *
FROM(SELECT DEPTNO, JOB, SAL
        FROM EMP)
PIVOT(MAX(SAL)
    FOR DEPTNO IN(10,20,30)
            )
ORDER BY JOB;

SELECT *
FROM(SELECT DEPTNO, JOB, SAL
        FROM EMP)
PIVOT(MAX(SAL)
        FOR JOB IN ('CLERK' AS CLERK1,
                'SALESMAN' AS SALESMAN1,
                'PRESIDENT' AS PRESIDENT1,
                'MANAGER' AS MANAGER1)
            )
ORDER BY JOB;


--P213 7장 Q1
SELECT DEPTNO
    , FLOOR(AVG(SAL)) AVG_SAL
    , MAX(SAL) MAX_SAL
    , MIN(SAL) MIN_SAL
    , COUNT(EMPNO) CNT
FROM EMP
GROUP BY DEPTNO;

SELECT NVL(TO_CHAR(DEPTNO), '부서없음')
    ,NVL(TRUNC(AVG(SAL)),0) AS AVG_SAL
    ,NVL(MAX(SAL),0) AS MAX_SAL
    ,NVL(MIN(SAL),0) AS MIN_SAL
    ,COUNT(*) AS CNT
FROM EMP
WHERE DEPTNO IS NOT NULL
GROUP BY DEPTNO
ORDER BY DEPTNO;

--Q2
SELECT JOB, COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(JOB)>=3;


SELECT JOB, COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(*)>=3;


--Q3
SELECT TO_CHAR(HIREDATE,'YYYY') AS HIRE_YEAR
    ,DEPTNO
    ,COUNT(HIREDATE) AS CNT
FROM EMP
GROUP BY HIREDATE;


SELECT TO_CHAR(HIREDATE, 'YYYY') AS HIRE_YEAR
    ,DEPTNO
    ,COUNT(*) AS CNT
FROM EMP
WHERE DEPTNO IS NOT NULL
GROUP BY  TO_CHAR(HIREDATE,'YYYY'), DEPTNO;

--Q4
SELECT NVL2(COMM,'O','X') AS EXIST_COMM
    , COUNT(*) AS CNT
FROM EMP
GROUP BY NVL2(COMM,'O','X');

SELECT NVL2(COMM,'O','X') AS EXIST_COMM
    ,COUNT(*) AS CNT
FROM EMP
GROUP BY NVL2(COMM,'O','X');

--Q5
SELECT DEPTNO
    ,TO_CHAR(HIREDATE,'YYYY') AS HIRE_YEAR
    ,COUNT(*) AS CNT
    ,MAX(SAL) AS MAX_SAL
    ,SUM(SAL) AS SUM_SAL
    ,AVG(SAL) AS AVG_SAL
FROM EMP
WHERE DEPTNO IS NOT NULL
GROUP BY ROLLUP(DEPTNO,TO_CHAR(HIREDATE,'YYYY'));

--P240 8장 Q1
SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E, DEPT D
WHERE E.SAL>2000
    AND E.DEPTNO=D.DEPTNO
ORDER BY E.DEPTNO, E.SAL;

SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E 
INNER JOIN DEPT D ON E.DEPTNO=D.DEPTNO
WHERE E.SAL>2000
ORDER BY E.DEPTNO, E.SAL;

--Q2
SELECT E.DEPTNO
    , D.DNAME
    , FLOOR(AVG(SAL)) AS AVG_SAL   
    , MAX(SAL) MAX_SAL
    , MIN(SAL) MIN_SAL
    , COUNT(*) CNT
FROM DEPT D , EMP E
WHERE E.DEPTNO=D.DEPTNO
GROUP BY E.DEPTNO, D.DNAME;

SELECT E.DEPTNO
    , D.DNAME
    , FLOOR(AVG(SAL)) AS AVG_SAL   
    , MAX(SAL) MAX_SAL
    , MIN(SAL) MIN_SAL
    , COUNT(*) CNT
FROM DEPT D 
JOIN EMP E ON E.DEPTNO=D.DEPTNO
GROUP BY E.DEPTNO, D.DNAME;


--Q3
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E , DEPT D
WHERE E.DEPTNO(+)=D.DEPTNO
ORDER BY D.DEPTNO, D.DNAME;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E 
RIGHT OUTER JOIN DEPT D ON E.DEPTNO=D.DEPTNO
ORDER BY D.DEPTNO, D.DNAME;


--Q4
SELECT E1.DEPTNO AS DEPTNO
    ,D.DNAME, E1.EMPNO, E1.ENAME
    ,NVL(TO_CHAR(E1.MGR),' ') AS MGR
    ,E1.SAL
    ,D.DEPTNO AS DEPTNO_1
    ,S.LOSAL, S.HISAL, S.GRADE
    ,NVL(TO_CHAR(E2.EMPNO),' ') AS MGR_EMPNO
    ,NVL(TO_CHAR(E2.ENAME),' ') AS MGR_ENAME
FROM EMP E1, EMP E2, DEPT D, SALGRADE S
WHERE E1.DEPTNO(+)=D.DEPTNO 
    AND E1.MGR=E2.EMPNO(+)
    AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
ORDER BY E1.DEPTNO, E1.EMPNO;

SELECT E1.DEPTNO AS DEPTNO
    ,D.DNAME, E1.EMPNO, E1.ENAME
    ,NVL(TO_CHAR(E1.MGR),' ') AS MGR
    ,E1.SAL
    ,D.DEPTNO AS DEPTNO_1
    ,S.LOSAL, S.HISAL, S.GRADE
    ,NVL(TO_CHAR(E2.EMPNO),' ') AS MGR_EMPNO
    ,NVL(TO_CHAR(E2.ENAME),' ') AS MGR_ENAME
FROM EMP E1
RIGHT OUTER JOIN DEPT D ON E1.DEPTNO=D.DEPTNO
LEFT OUTER JOIN EMP E2 ON E1.MGR=E2.EMPNO
LEFT OUTER JOIN SALGRADE S ON E1.SAL>=S.LOSAL AND E1.SAL<=S.HISAL
--LEFT OUTER JOIN SALGRADE S ON E1.SAL<=S.HISAL
ORDER BY E1.DEPTNO, E1.EMPNO;

/*WITH(VIEW 개념과 비슷)
    WITH
    별칭 AS SELECT.....
    
    SELECT
    FROM 별칭
*/

WITH
E10 AS (SELECT * FROM EMP WHERE DEPTNO=10),
D AS (SELECT * FROM DEPT)
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM E10, D
WHERE E10.DEPTNO=D.DEPTNO;

SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO=10) E10
,(SELECT * FROM DEPT) D
WHERE E10.DEPTNO=D.DEPTNO;

--P262 9장 Q1
SELECT E.JOB, E.EMPNO,E.ENAME, E.SAL, D.DEPTNO, D.DNAME 
FROM EMP E, DEPT D
WHERE JOB='SALESMAN'
    AND E.DEPTNO=D.DEPTNO
ORDER BY SAL DESC;

SELECT E.JOB, E.EMPNO,E.ENAME,E.SAL,E.DEPTNO,D.DNAME
FROM EMP E
JOIN DEPT D ON E.DEPTNO=D.DEPTNO
WHERE E.JOB=(SELECT E1.JOB FROM EMP E1 WHERE E1.ENAME='ALLEN');

--Q2
SELECT EMPNO, ENAME, DNAME
    , TO_CHAR(HIREDATE, 'YYYY-MM-DD') AS HIREDATE
    , LOC, SAL, GRADE
FROM EMP , DEPT , SALGRADE
WHERE SAL>(SELECT AVG(SAL) FROM EMP)
    AND SAL BETWEEN SALGRADE.LOSAL AND SALGRADE.HISAL
    AND EMP.DEPTNO=DEPT.DEPTNO
ORDER BY SAL DESC, EMPNO;



SELECT E.EMPNO,E.ENAME,D.DNAME
    ,TO_CHAR(HIREDATE, 'YYYY-MM-DD') HIREDATE
    ,D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO=D.DEPTNO 
    AND E.SAL BETWEEN S.LOSAL AND S.HISAL
    AND SAL>(SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO;

--Q3
SELECT E1.EMPNO, E1.ENAME, E1.JOB, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E1, DEPT D
WHERE E1.DEPTNO=D.DEPTNO
    AND E1.DEPTNO=10
    AND E1.JOB NOT IN(SELECT DISTINCT JOB
                     FROM EMP 
                     WHERE DEPTNO=30);


SELECT E.EMPNO, E.ENAME, E.JOB, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO
    AND E.DEPTNO=10
    AND E.JOB NOT IN(SELECT DISTINCT E.JOB
                FROM EMP E
                WHERE E.DEPTNO=30);
--SELECT DISTINCT E.JOB
--FROM EMP E
--WHERE E.DEPTNO=30;

    
--Q4
SELECT EMP.EMPNO, EMP.ENAME, EMP.SAL, SALGRADE.GRADE
FROM  EMP, SALGRADE
WHERE EMP.SAL>(SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN')
    AND EMP.SAL BETWEEN SALGRADE.LOSAL AND SALGRADE.HISAL
ORDER BY EMPNO;
    
    
    
WITH
E AS (SELECT * FROM EMP),
S AS (SELECT * FROM SALGRADE)
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
FROM E, S
WHERE E.SAL>(SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN')
    AND E.SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY EMPNO;

SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
FROM (SELECT * FROM EMP) E
    ,(SELECT * FROM SALGRADE) S
WHERE E.SAL>(SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN')
    AND E.SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY EMPNO;   
    



SELECT E.EMPNO, E.ENAME,E.SAL,S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
    AND SAL>(SELECT MAX(SAL)
        FROM EMP
        WHERE JOB='SALESMAN')
ORDER BY E.EMPNO;

SELECT E.EMPNO, E.ENAME,E.SAL,S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
    AND SAL>ALL(SELECT DISTINCT SAL
        FROM EMP
        WHERE JOB='SALESMAN')
ORDER BY E.EMPNO;
    
    
    
    
    
    
    
    
    
    
    
    
CREATE TABLE SAL_DDL
AS SELECT * FROM SALGRADE WHERE 1<>1;    
    
CREATE TABLE SAL_DML
AS SELECT * FROM SALGRADE WHERE 1<>1;

DESC SAL_DML;
SELECT * FROM SAL_DML;

SELECT * FROM SAL_TCL;
TRUNCATE TABLE SAL_TCL; 

INSERT INTO SAL_TCL
SELECT GRADE,LOSAL,HISAL
FROM SALGRADE;

INSERT INTO SAL_TCL(GRADE, LOSAL)
SELECT GRADE, LOSAL
FROM SALGRADE
WHERE GRADE=2;

INSERT INTO SAL_TCL
SELECT (SELECT MAX(GRADE)+1 FROM SALGRADE)
    ,(SELECT MIN(LOSAL)-1 FROM SALGRADE)
    ,(SELECT MAX(HISAL)-1 FROM SALGRADE)
FROM SALGRADE;

/*INSERT INTO
    INSERT ALL 만족하면 다 들어가고
    INSERT FRIST 만족하는 값을 만나면 멈춘다
    
*/
INSERT ALL
    WHEN LOSAL>=2001 THEN
        INTO SAL_DML VALUES(GRADE, LOSAL,HISAL)
    WHEN LOSAL>=1000 THEN
        INTO SAL_TCL VALUES(GRADE, LOSAL,HISAL)
    ELSE 
        INTO SAL_DDL VALUES(GRADE, LOSAL, HISAL)
SELECT GRADE, LOSAL, HISAL
FROM SALGRADE;
        
SELECT * FROM SAL_DML;
SELECT * FROM SAL_TCL;
SELECT * FROM SAL_DDL;

TRUNCATE TABLE SAL_DML;
TRUNCATE TABLE SAL_TCL;
TRUNCATE TABLE SAL_DDL;

/*MERGE
    쓸일이 없다 혹시...
    
    
*/
MERGE 
INTO EMP E
USING DUAL --TABLE VIEW SUBQUERY 
ON (E.EMPNO=7704)
WHEN MATCHED
THEN UPDATE SET E.SAL=1000
WHEN NOT MATCHED
THEN INSERT (E.EMPNO, E.ENAME, E.SAL, E.DEPTNO)
    VALUES(7704, 'SCOTT' , 2000, 20);

SELECT * FROM EMP WHERE ENAME='SCOTT';

SELECT * FROM SAL_TCL;

MERGE 
INTO SAL_TCL ST
USING (SELECT S.GRADE, S.LOSAL, S.HISAL
        FROM SAL_DDL S
        WHERE S.GRADE=1) R
ON (ST.GRADE=R.GRADE)
WHEN MATCHED
THEN UPDATE SET ST.LOSAL=R.LOSAL, ST.HISAL=R.HISAL
WHEN NOT MATCHED
THEN INSERT (ST.GRADE, ST.LOSAL, ST.HISAL)
    VALUES(R.GRADE, R.LOSAL, R.HISAL);
    
UPDATE SAL_DDL SET LOSAL=1000, HISAL=2000;
